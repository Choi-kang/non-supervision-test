1.牛顿法
首先你需要知道的是牛顿法本身是一个求解函数零点的算法。它通过迭代方式逐步逼近函数零点，不了解的同学可以先看一下这篇知乎回答如何通俗易懂地讲解牛顿迭代法求开方？
现在问题来了，最优化问题是如何与函数零点勾搭上的？对于一个二阶偏导连续的函数f(x)来说，他的极小值点一定梯度为零，那么我们通过找到f(x)梯度为零的点不就找到了极小值嘛？(当然需要加上这个驻点的海森矩阵为正定矩阵这个条件才能严谨的说明其为极小值点，这里暂不考虑)
好吧，现在问题已经变为找f(x)梯度的零点。假设我们已经在xk处，现在我们想知道下一步怎么跨才能跳到梯度的零点。突然发现好像有点难。。。。这时候牛顿法出来了，找不到真实梯度(比较复杂)的零点不要紧，我们可以看下xk附近点的近似梯度面，看看这个近似梯度的零点在哪里不就好了。行，那我们来试试。
先对f(x)在xk处二阶泰勒展开

接着对上式两边同时求梯度，得到

上式的右边即为xk附近点的近似梯度，现在我们要找这个近似梯度的零点。太简单了，只要令这个近似梯度为0，反解出x就好。经过推导，我们可以得到：

好了，现在我们站到了xk+1处，可是xk+1只是近似梯度为0，所以我们还想更进一步，怎么办？简单啊，把刚才对xk做的事情再对xk+1做一遍不就好了，这样我们就来到了xk+2处，如果不满意，我们可以继续做下去，得到xk+3 , xk+4 , xk+5........，直到这个点满足我们所要的精度。以上就是牛顿法求解无约束最优化问题的大概思路，具体算法见<统计学习方法>附录
需要说明的是，因为牛顿法是二阶收敛，所以比梯度下降要快。具体可以参考牛顿法为什么比梯度下降法求解需要的迭代次数更少?
使用牛顿法需要注意的地方可以参考对牛顿法的几点补充
2拟牛顿法
刚才已经介绍了牛顿法，可是真正使用的时候却出现了一些问题。比如牛顿法每次迭代都需要计算当前点的海森矩阵，同时还要计算它的逆，好麻烦啊，有没有简单的一些方法？比如直接计算出当前点海森矩阵的逆？那我们就来看一看行不行。
假设现在我们已经到了xk+1这个点，现在想跑向xk+2，按照牛顿法需要计算xk+1这个点的梯度和海森矩阵的逆。现在让我们来对xk+1这个点进行二阶泰勒展开

然后对两边同时求梯度，得到xk+1附近点的近似梯度

令x=xk，再对上式进行整理，可以得到以下两个式子

或者

• 代码实现：
用牛顿法求解 f = 100 * (x2-x1** 2) ** 2 + (1-x1)**2
import numpy as np
import matplotlib.pyplot as plt

#梯度的公式
def tidu(x):
    return np.array([-400*x[0]*(x[1]-x[0]**2)-2*(1-x[0]),200*(x[1]-x[0]**2)])

#海森矩阵的公式
def hessian(x):
    return np.array([[-400*(x[1]-3*x[0]**2)+2,-400*x[0]],[-400*x[0],200]])

#牛顿法
def newton(x):
    print("初始点为 : ",x)
    res=[]
    res.append(x)
    i = 1
    imax = 1000
    delta = 1
    #迭代的条件是小于imax，或者是更新的距离小于一个很小的数值
    while i<imax and delta>10**(-5):
        p = -np.dot(np.linalg.inv(hessian(x)),tidu(x))
        x_new = x + p
        res.append(x_new)
        delta = sum((x-x_new)**2)   # 更新的距离
        print("初始点为 : ",x_new)
        i=i+1
        x=x_new  # 更新x
    return np.array(res)


if __name__ =="__main__":
    # 用牛顿法求解  f=100*(x2-x1**2)**2+(1-x1)**2
    X1=np.arange(-1.5,1.5+0.05,0.05)
    X2=np.arange(-3.5,2+0.05,0.05)
    [x1,x2]=np.meshgrid(X1,X2)
    f=100*(x2-x1**2)**2+(1-x1)**2;   # 给定的函数
    plt.contour(x1,x2,f,20)          # 画出函数的20条轮廓线

    x0 = np.array([-1.2,1])
    res=newton(x0)

    res_x=res[:,0]
    res_y=res[:,1]
    plt.plot(res_x,res_y)
    plt.show()


