{'user': 'acct:corenel@hypothes.is', 'text': '在本章中', 'origin_text': '                              !!!本章!!!  ，我们将介绍如何使用深度学习解决计算机视觉、语音识别、自然语言处', 'time': '2017-01-19T11:11'}
{'user': 'acct:corenel@hypothes.is', 'text': '来解决', 'origin_text': '              本章，我们将介绍如何使用深度学习  !!!解决!!!  计算机视觉、语音识别、自然语言处理以及其他商业领域中的应用。首', 'time': '2017-01-19T11:11'}
{'user': 'acct:corenel@hypothes.is', 'text': '首先，我们将讨论在许多重要的AI应用中所需的大规模神经网络的实现。', 'origin_text': '解决计算机视觉、语音识别、自然语言处理以及其他商业领域中的应用。  !!!首先我们讨论在许多最重要的AI应用中所需的大规模神经网络的实现。!!!  接着，我们回顾深度学习已经成功应用的几个特定领域。尽管深度学', 'time': '2017-01-19T11:14'}
{'user': 'acct:corenel@hypothes.is', 'text': '其次，我们将回顾深度学习已经成功应用的几个特定领域。', 'origin_text': '先我们讨论在许多最重要的AI应用中所需的大规模神经网络的实现。  !!!接着，我们回顾深度学习已经成功应用的几个特定领域。!!!  尽管深度学习的一个目标是设计能够处理各种任务的算法，然而截止目', 'time': '2017-01-19T11:15'}
{'user': 'acct:corenel@hypothes.is', 'text': '深度学习的应用', 'origin_text': '尽管深度学习的一个目标是设计能够处理各种任务的算法，然而截止目前  !!!应用深度学习!!!  仍然需要一定程度的特殊化。例如，计算机视觉中的任务对每一个样本', 'time': '2017-01-19T11:16'}
{'user': 'acct:corenel@hypothes.is', 'text': '其中一个关键的因素就是网络规模的巨大提升', 'origin_text': '纪80年代，如今神经网络的精度以及处理任务的复杂度都有一定提升，  !!!网络规模的巨大提升是一个关键的因素!!!  。正如我们在\\sec?中看到的一样，在过去的三四十年中，网络规', 'time': '2017-01-19T11:25'}
{'user': 'acct:corenel@hypothes.is', 'text': '在过去的三十年内', 'origin_text': '的巨大提升是一个关键的因素。正如我们在\\sec?中看到的一样，  !!!在过去的三四十年中!!!  ，网络规模是以指数级的速度递增的，尽管如今的人工神经网络的规模也', 'time': '2017-01-19T11:29'}
{'user': 'acct:corenel@hypothes.is', 'text': '。然而如今的人工神经网络的规模也仅仅和昆虫的神经系统差不多。', 'origin_text': '中看到的一样，在过去的三四十年中，网络规模是以指数级的速度递增的  !!!，尽管如今的人工神经网络的规模也仅仅和昆虫的神经系统差不多。!!!  大规模神经网络的必要性，所以深度学习需要高性能的硬件设施和软', 'time': '2017-01-19T11:30'}
{'user': 'acct:corenel@hypothes.is', 'text': '由于规模的大小对于神经网络来说至关重要，因此深度学习需要高性能的硬件设施和软件实现。', 'origin_text': '，尽管如今的人工神经网络的规模也仅仅和昆虫的神经系统差不多。  !!!大规模神经网络的必要性，所以深度学习需要高性能的硬件设施和软件实现。!!!  快速的CPU实现传统的神经网络是用单台机器的CPU来训', 'time': '2017-01-19T11:34'}
{'user': 'acct:corenel@hypothes.is', 'text': '得', 'origin_text': '11年，最好的CPU在训练神经网络时使用定点运算能够比浮点运算跑  !!!的!!!  更快。通过调整定点运算的实现方式，{Vanhoucke-et-', 'time': '2017-01-19T11:39'}
{'user': 'acct:corenel@hypothes.is', 'text': '3倍于一个强浮点运算系统的速度', 'origin_text': '算的实现方式，{Vanhoucke-et-al-2011}获得了  !!!相对一个很强的浮点运算系统3倍的加速!!!  。因为各个新型CPU都有各自不同的特性，所以有时候采用浮点运算', 'time': '2017-01-19T13:16'}
{'user': 'acct:corenel@hypothes.is', 'text': '一条重要的准则就是，通过特殊设计的数值运算，我们可以获得巨大的回报。', 'origin_text': '型CPU都有各自不同的特性，所以有时候采用浮点运算实现会更快。  !!!一条重要的准则就是通过特殊设计的数值运算可以获得巨大的回报。!!!  除了选择定点运算或者浮点运算以外，还包括其他的策略，如通过优化', 'time': '2017-01-19T11:50'}
{'user': 'acct:corenel@hypothes.is', 'text': '其他的策略还包括了如', 'origin_text': '数值运算可以获得巨大的回报。除了选择定点运算或者浮点运算以外，  !!!还包括其他的策略，如!!!  通过优化数据结构避免高速缓存缺失、使用向量指令等。如果模型规模', 'time': '2017-01-19T11:51'}
{'user': 'acct:corenel@hypothes.is', 'text': '图形处理器（GPU）最初是为图形应用而开发的专用硬件组件。', 'origin_text': '。GPU 实现许多现代神经网络的实现基于图形处理器。  !!!GPU是一种特殊设计的硬件，设计的原始目的是为了处理图形应用!!!  。视频游戏系统的消费市场刺激了图形处理硬件的发展。它为视频游', 'time': '2017-01-19T12:04'}
{'user': 'acct:corenel@hypothes.is', 'text': '视频游戏的渲染', 'origin_text': '展。它为视频游戏所设计的特性也可以使神经网络的计算受益。  !!!视频游戏!!!  要求许多操作能够快速并行地实现。环境和角色模型通过一系列顶点的', 'time': '2017-01-19T12:06'}
{'user': 'acct:corenel@hypothes.is', 'text': '显卡必须并行地对许多顶点执行矩阵乘法与除法', 'origin_text': '的3D坐标确定。为了将大量的3D坐标转化为2D显示器上的坐标，  !!!显卡必须快速实现矩阵乘法或者除法!!!  。之后，显卡必须并行地实现每个像素上的计算来确定每个像素点的颜', 'time': '2017-01-19T12:09'}
{'user': 'acct:corenel@hypothes.is', 'text': '执行', 'origin_text': '以使神经网络的计算受益。视频游戏要求许多操作能够快速并行地  !!!实现!!!  。环境和角色模型通过一系列顶点的3D坐标确定。为了将大量的3', 'time': '2017-01-19T12:09'}
{'user': 'acct:corenel@hypothes.is', 'text': '显卡必须并行地在每个像素上执行诸多计算，', 'origin_text': '为2D显示器上的坐标，显卡必须快速实现矩阵乘法或者除法。之后，  !!!显卡必须并行地实现每个像素上的计算!!!  来确定每个像素点的颜色。在这两种情况下，计算都是非常简单的，并', 'time': '2017-01-19T12:10'}
{'user': 'acct:corenel@hypothes.is', 'text': '不需要通过{\\tt if}语句来判断确定每个顶点需要乘哪个矩阵\n', 'origin_text': '算。例如，同一个刚体内的每个顶点都会乘上相同的矩阵；也就是说，  !!!不需要通过{\\tt if}判断确定顶点需要乘哪个矩阵!!!  。计算过程也是完全相互独立的，因此也能够并行操作。计算过程还', 'time': '2017-01-19T12:12'}
{'user': 'acct:corenel@hypothes.is', 'text': '各个计算过程之间', 'origin_text': '就是说，不需要通过{\\tt if}判断确定顶点需要乘哪个矩阵。  !!!计算过程!!!  也是完全相互独立的，因此也能够并行操作。计算过程还涉及处理大量', 'time': '2017-01-19T12:13'}
{'user': 'acct:corenel@hypothes.is', 'text': '能够实现并行操作', 'origin_text': '}判断确定顶点需要乘哪个矩阵。计算过程也是完全相互独立的，因此  !!!也能够并行操作!!!  。计算过程还涉及处理大量内存缓冲以及描述每一个对象的纹理（颜色', 'time': '2017-01-19T12:14'}
{'user': 'acct:corenel@hypothes.is', 'text': '描述每一个需要被渲染的对象的纹理（颜色模式）的位图信息', 'origin_text': '独立的，因此也能够并行操作。计算过程还涉及处理大量内存缓冲以及  !!!描述每一个对象的纹理（颜色模式）如何渲染的位图信息!!!  。总的来说，这使显卡设计为拥有高度并行特性以及很高的内存带宽，', 'time': '2017-01-19T12:15'}
{'user': 'acct:corenel@hypothes.is', 'text': '神经网络算法所需要的性能特性是相同的', 'origin_text': '度以及更弱的处理分支运算的能力。与上述的实时图形算法相比，  !!!神经网络算法需要的是相同的性能特性!!!  。神经网络算法通常涉及大量参数、激活值、梯度值的缓冲区，其中每', 'time': '2017-01-19T12:17'}
{'user': 'acct:corenel@hypothes.is', 'text': 'GPU一个显著的优势是其极高的内存带宽', 'origin_text': '存(cache)，所以内存带宽通常会成为主要瓶颈。相比CPU，  !!!GPU极高的内存带宽成为了一个显著的优势!!!  。神经网络的训练算法通常并不涉及分支运算和复杂的控制指令，所以', 'time': '2017-01-19T12:28'}
{'user': 'acct:corenel@hypothes.is', 'text': '通常并不涉及大量的分支运算与复杂的控制指令', 'origin_text': 'PU极高的内存带宽成为了一个显著的优势。神经网络的训练算法通常  !!!并不涉及分支运算和复杂的控制指令!!!  ，所以更适合在GPU硬件上训练。由于神经网络能够被分为多个单独', 'time': '2017-01-19T12:31'}
{'user': 'acct:corenel@hypothes.is', 'text': '只要将计算的输出值作为像素值写入缓冲区，GPU就可以用于科学计算', 'origin_text': '颜色的任务。原则上，GPU不要求这些像素值实际基于渲染任务。  !!!将计算的输出值作为像素值写入缓冲区，GPU可以用于科学计算!!!  。{Steinkrau2005}在GPU上实现了一个两层全连接', 'time': '2017-01-19T12:35'}
{'user': 'acct:corenel@hypothes.is', 'text': '加速监督卷积网络的训练', 'origin_text': 'lla:inria-00112631}也论证了相同的技术可以用来  !!!加速训练监督卷积网络!!!  。使用显卡训练神经网络的热度在通用GPU发布以后开始爆炸性', 'time': '2017-01-19T12:37'}
{'user': 'acct:corenel@hypothes.is', 'text': '在通用GPU发布以后，使用显卡训练神经网络的热度开始爆炸性地增长', 'origin_text': '2631}也论证了相同的技术可以用来加速训练监督卷积网络。  !!!使用显卡训练神经网络的热度在通用GPU发布以后开始爆炸性增长!!!  。这种通用GPU可以执行任意的代码，而并非仅仅渲染子程序。N', 'time': '2017-01-19T12:38'}
{'user': 'acct:corenel@hypothes.is', 'text': '模型', 'origin_text': '得我们可以用一种像C一样的语言实现任意代码。由于相对简便的编程  !!!语言!!!  ，强大的并行能力以及巨大的内存带宽，通用GPU为我们提供了训练神', 'time': '2017-01-19T12:39'}
{'user': 'acct:corenel@hypothes.is', 'text': '所采用', 'origin_text': '理想平台。在它发布以后不久，这个平台就迅速被深度学习的研究者们  !!!接纳了!!!  {cite?}。如何在通用GPU上写高效的代码依然是一个难题', 'time': '2017-01-19T12:40'}
{'user': 'acct:corenel@hypothes.is', 'text': '良好', 'origin_text': '如何在通用GPU上写高效的代码依然是一个难题。在GPU上获得  !!!很好!!!  表现所需的技术与CPU上的技术非常不同。比如说，基于CPU的良', 'time': '2017-01-19T12:45'}
{'user': 'acct:corenel@hypothes.is', 'text': '访问', 'origin_text': '联读/写数据的方式。通常来说，如果在nnn个线程中，线程iii  !!!对应!!!  的是第i+ji+ji+j处的内存，其中jjj是222的某个幂的倍', 'time': '2017-01-19T13:20'}
{'user': 'acct:corenel@hypothes.is', 'text': '，那么内存操作就易于级联。', 'origin_text': '是第i+ji+ji+j处的内存，其中jjj是222的某个幂的倍数  !!!。!!!  具体的设定在不同的GPU型号中有所区别。GPU另一个常见的设', 'time': '2017-01-19T13:21'}
{'user': 'acct:corenel@hypothes.is', 'text': '难以执行分支操作', 'origin_text': '的设定是使一个组中的所有线程都同时执行同一指令。这意味着GPU  !!!上的分支操作是很困难的!!!  。线程被分为一个个称作warp的小组。在一个warp中的每一', 'time': '2017-01-19T13:22'}
{'user': 'acct:corenel@hypothes.is', 'text': '组织好', 'origin_text': '非并行的方式。由于实现高效GPU代码的困难性，研究人员应该  !!!构建!!!  他们的工作流程，避免对每一个新的模型或算法都编写新的GPU代码。', 'time': '2017-01-19T13:24'}
{'user': 'acct:corenel@hypothes.is', 'text': '机器学习库Pylearn2 {cite?}将其所有的机器学习算法都通过调用Theano {cite?}和cuda-convnet {cite?}所提供的高性能操作来指定。', 'origin_text': '件库解决这个问题，然后再从库中调用所需要的操作确定模型。例如，  !!!机器学习库Pylearn2 {cite?}通过调用Theano {cite?}和cuda-convnet {cite?}提供的高性能操作，囊括了许多机器学习算法!!!  。这种分解方法还可以简化对多种硬件的支持。例如，同一个The', 'time': '2017-01-19T13:29'}
{'user': 'acct:corenel@hypothes.is', 'text': '因此，', 'origin_text': '规模的分布式实现在许多情况下，单个机器的计算资源是有限的。  !!!因此!!!  我们希望把训练或者推断的任务分摊到多个机器上进行。分布式的', 'time': '2017-01-20T03:06'}
{'user': 'acct:corenel@hypothes.is', 'text': '\\emph{数据并行}', 'origin_text': '现的，因为每一个输入的样本都可以在单独的机器上运行。这也被称为  !!!数据并行!!!  。同样的，模型并行也是可行的，其中多个机器共同运行一个数据点', 'time': '2017-01-20T03:09'}
{'user': 'acct:corenel@hypothes.is', 'text': '同样地', 'origin_text': '个输入的样本都可以在单独的机器上运行。这也被称为数据并行。  !!!同样的!!!  ，模型并行也是可行的，其中多个机器共同运行一个数据点，每一个机器', 'time': '2017-01-20T03:09'}
{'user': 'acct:corenel@hypothes.is', 'text': '\\emph{模型并行}', 'origin_text': '样本都可以在单独的机器上运行。这也被称为数据并行。同样的，  !!!模型并行!!!  也是可行的，其中多个机器共同运行一个数据点，每一个机器负责模型的', 'time': '2017-01-20T03:10'}
{'user': 'acct:corenel@hypothes.is', 'text': '训练', 'origin_text': '器共同运行一个数据点，每一个机器负责模型的一个部分。对于推断和  !!!学习!!!  ，这都是可行的。训练中，数据并行在某种程度上说更难。对于', 'time': '2017-01-20T03:10'}
{'user': 'acct:corenel@hypothes.is', 'text': '在训练过程中，数据并行某种程度上来说更加困难', 'origin_text': '个机器负责模型的一个部分。对于推断和学习，这都是可行的。  !!!训练中，数据并行在某种程度上说更难!!!  。对于随机梯度下降的单步来说，我们可以增加minibatch的', 'time': '2017-01-20T03:39'}
{'user': 'acct:corenel@hypothes.is', 'text': '通常我们得到的回报并不会线性增长', 'origin_text': '我们可以增加minibatch的大小，但是从优化性能的角度来说，  !!!通常我们得到反馈少于线性的反馈!!!  。使用多个机器并行地计算多个梯度下降步是一个更好的选择。不幸', 'time': '2017-01-20T03:42'}
{'user': 'acct:corenel@hypothes.is', 'text': '步骤', 'origin_text': '我们得到反馈少于线性的反馈。使用多个机器并行地计算多个梯度下降  !!!步!!!  是一个更好的选择。不幸的是，梯度下降的标准定义完全是一个串行的', 'time': '2017-01-20T03:43'}
{'user': 'acct:corenel@hypothes.is', 'text': '看', 'origin_text': '来说，我们可以增加minibatch的大小，但是从优化性能的角度  !!!来说!!!  ，通常我们得到反馈少于线性的反馈。使用多个机器并行地计算多个梯', 'time': '2017-01-20T03:52'}
{'user': 'acct:corenel@hypothes.is', 'text': '并', 'origin_text': '理器的核共用存有参数的内存。每一个核在无锁情况下读取了这些参数  !!!，然后!!!  计算对应的梯度，然后在无锁状态下更新了这些参数。这种方法减少了', 'time': '2017-01-20T03:54'}
{'user': 'acct:corenel@hypothes.is', 'text': '删去 了', 'origin_text': '中，几个处理器的核共用存有参数的内存。每一个核在无锁情况下读取  !!!了!!!  这些参数，然后计算对应的梯度，然后在无锁状态下更新了这些参数。', 'time': '2017-01-20T03:54'}
{'user': 'acct:corenel@hypothes.is', 'text': '删去 了', 'origin_text': '锁情况下读取了这些参数，然后计算对应的梯度，然后在无锁状态下更新  !!!了!!!  这些参数。这种方法减少了每一个梯度下降所获得的平均提升，因为一', 'time': '2017-01-20T03:54'}
{'user': 'acct:corenel@hypothes.is', 'text': '由于一些核把其他的核所更新的参数覆盖了，因此这种方法减少了每一步梯度下降所获得的平均提升。', 'origin_text': '这些参数，然后计算对应的梯度，然后在无锁状态下更新了这些参数。  !!!这种方法减少了每一个梯度下降所获得的平均提升，因为一些核把其他的核所更新的参数（写）覆盖了。!!!  但因为更新步数的速率增加，总体上还是加快了学习过程。{Dea', 'time': '2017-01-20T04:34'}
{'user': 'acct:corenel@hypothes.is', 'text': '\\emph{参数服务器}', 'origin_text': 'IPS2012}率先提出了多机器无锁的梯度下降方法，其中参数是由  !!!参数服务器!!!  管理而非存储在共用的内存中。分布式的异步梯度下降方法依然是训练', 'time': '2017-01-20T04:34'}
{'user': 'acct:corenel@hypothes.is', 'text': '保留了', 'origin_text': '参数服务器管理而非存储在共用的内存中。分布式的异步梯度下降方法  !!!依然是!!!  训练深度神经网络的基本方法，被工业界很多机器学习组所使用{cit', 'time': '2017-01-20T04:35'}
{'user': 'acct:corenel@hypothes.is', 'text': '基本策略', 'origin_text': '共用的内存中。分布式的异步梯度下降方法依然是训练深度神经网络的  !!!基本方法!!!  ，被工业界很多机器学习组所使用{cite?}。学术界的深度学习', 'time': '2017-01-20T04:35'}
{'user': 'acct:corenel@hypothes.is', 'text': '并被', 'origin_text': '中。分布式的异步梯度下降方法依然是训练深度神经网络的基本方法，  !!!被!!!  工业界很多机器学习组所使用{cite?}。学术界的深度学习研究', 'time': '2017-01-20T04:35'}
{'user': 'acct:corenel@hypothes.is', 'text': '仍专注于', 'origin_text': '学习研究者们通常无法负担那么大规模的分布式学习系统，但是一些研究  !!!关注于!!!  如何在校园环境中相对较廉价的硬件系统中构造分布式网络{cite?', 'time': '2017-01-20T04:37'}
{'user': 'acct:corenel@hypothes.is', 'text': '使用相对廉价的硬件系统', 'origin_text': '担那么大规模的分布式学习系统，但是一些研究关注于如何在校园环境中  !!!相对较廉价的硬件系统中!!!  构造分布式网络{cite?}。模型压缩在许多商业应', 'time': '2017-01-20T04:38'}
{'user': 'acct:corenel@hypothes.is', 'text': '开发者们', 'origin_text': '在许多情况下，相比开发者，终端用户的可用资源往往更有限。例如，  !!!研究者们!!!  可以使用巨大的计算机集群训练一个语音识别的网络，然后发布到移动手', 'time': '2017-01-20T04:39'}
{'user': 'acct:corenel@hypothes.is', 'text': '然后将其部署到手机上', 'origin_text': '例如，研究者们可以使用巨大的计算机集群训练一个语音识别的网络，  !!!然后发布到移动手机上!!!  。减少推断所需开销的一个关键策略是模型压缩{cite?}。', 'time': '2017-01-20T04:40'}
{'user': 'acct:corenel@hypothes.is', 'text': '\\emph{模型压缩}', 'origin_text': '网络，然后发布到移动手机上。减少推断所需开销的一个关键策略是  !!!模型压缩!!!  {cite?}。模型压缩的基本思想是用一个更小的模型取代替原始', 'time': '2017-01-20T04:40'}
{'user': 'acct:corenel@hypothes.is', 'text': '从而使得用来存储于评估所需的内存与运行时间更少', 'origin_text': '}。模型压缩的基本思想是用一个更小的模型取代替原始耗时的模型，  !!!只需更少内存和运行时间来存储和评估!!!  。原始模型的规模很大，且主要为了防止过拟合时，模型压缩可以起', 'time': '2017-01-20T05:06'}
{'user': 'acct:corenel@hypothes.is', 'text': '当原始模型由于为了防止过拟合而变得很大时', 'origin_text': '型取代替原始耗时的模型，只需更少内存和运行时间来存储和评估。  !!!原始模型的规模很大，且主要为了防止过拟合时!!!  ，模型压缩可以起到作用。在许多情况下，拥有最小泛化误差的模型往', 'time': '2017-01-20T05:16'}
{'user': 'acct:corenel@hypothes.is', 'text': '的成本很高', 'origin_text': '型往往是多个独立训练而成的模型的集成。评估所有nnn个集成成员  !!!是昂贵的!!!  。有时候，当单个模型很大（例如，如果它使用Dropout正则化', 'time': '2017-01-20T10:01'}
{'user': 'acct:corenel@hypothes.is', 'text': '能够学习到某个函数$f(x)$', 'origin_text': 'ropout正则化）时，其泛化能力也会很好。这些巨大的模型  !!!学习某个函数f(x)f(x)f(\\Vx)时!!!  ，但选用的参数数量超过了任务所需的参数数量。仅仅训练样本数是有', 'time': '2017-01-20T10:04'}
{'user': 'acct:corenel@hypothes.is', 'text': '只是因为训练样本数是有限的，所以模型的规模才变得必要。', 'origin_text': 'x)f(\\Vx)时，但选用的参数数量超过了任务所需的参数数量。  !!!仅仅训练样本数是有限的，所以网络的规模是受限的。!!!  只要我们拟合了这个函数f(x)f(x)f(\\Vx)，我们就可以', 'time': '2017-01-20T10:29'}
{'user': 'acct:corenel@hypothes.is', 'text': '我们就可以通过将$f$应用与随机采样点$x$，来生成有无穷多训练样本的训练集', 'origin_text': '是受限的。只要我们拟合了这个函数f(x)f(x)f(\\Vx)，  !!!我们就可以生成一个拥有了无穷多训练样本的训练集，只需将fff作用于任意生成的xx\\Vx。!!!  然后，我们使用这些样本训练一个新的更小的模型，在这些点上拟合f', 'time': '2017-01-20T10:31'}
{'user': 'acct:corenel@hypothes.is', 'text': '使其能够在', 'origin_text': '成的xx\\Vx。然后，我们使用这些样本训练一个新的更小的模型，  !!!在!!!  这些点上拟合f(x)f(x)f(\\Vx)。为了更加充分地利用了', 'time': '2017-01-20T10:32'}
{'user': 'acct:corenel@hypothes.is', 'text': '最好从类似于之后将提供给模型的真实测试数据的分布中', 'origin_text': '(x)f(\\Vx)。为了更加充分地利用了这个新的小模型的容量，  !!!最好能够从一个类似于真实的测试数据（后面会用到）的分布中!!!  采样xx\\Vx。这个过程可以通过损坏训练样本或者从原始训练数据', 'time': '2017-01-20T10:37'}
{'user': 'acct:corenel@hypothes.is', 'text': '\\emph{动态结构}', 'origin_text': '一般来说，加速数据处理系统的一种策略是构造一个系统，这个系统用  !!!动态结构!!!  描述图中处理输入的所需计算过程。在给定一个输入的情况中，数据处', 'time': '2017-01-20T10:39'}
{'user': 'acct:corenel@hypothes.is', 'text': '\\emph{条件计算}', 'origin_text': '隐藏单元）哪一部分用于计算。这种神经网络中的动态结构有时被称为  !!!条件计算!!!  {cite?}。由于模型结构许多部分可能只跟输入的一小部分有关', 'time': '2017-01-20T10:51'}
{'user': 'acct:corenel@hypothes.is', 'text': '\\emph{级联}', 'origin_text': '集需要应用于特定的输入。在分类器中加速推断的可行策略是使用  !!!级联!!!  的分类器。当目标是检测罕见对象（或事件）的是否存在，可以应用级', 'time': '2017-01-20T10:56'}
{'user': 'acct:corenel@hypothes.is', 'text': '当目标是检测罕见对象（或事件）是否存在时', 'origin_text': '的输入。在分类器中加速推断的可行策略是使用级联的分类器。  !!!当目标是检测罕见对象（或事件）的是否存在!!!  ，可以应用级联策略。要确定对象是否存在，我们必须使用具有高容量', 'time': '2017-01-20T10:57'}
{'user': 'acct:corenel@hypothes.is', 'text': '高容量、运行成本高', 'origin_text': '否存在，可以应用级联策略。要确定对象是否存在，我们必须使用具有  !!!高容量、运行昂贵!!!  的复杂分类器。 然而，因为对象是罕见的，我们通常可以使用更少的', 'time': '2017-01-20T10:59'}
{'user': 'acct:corenel@hypothes.is', 'text': '第一个', 'origin_text': '对象的输入。在这些情况下，我们可以训练一序列分类器。序列中的  !!!第一!!!  分类器具有低容量，训练为具有高召回率。换句话说，他们被训练为确', 'time': '2017-01-20T11:00'}
{'user': 'acct:corenel@hypothes.is', 'text': '最后一个', 'origin_text': '换句话说，他们被训练为确保对象存在时，我们不会错误地拒绝输入。  !!!最终的!!!  分类器训练为具有高精度。在测试时，我们按照顺序运行分类器进行推', 'time': '2017-01-20T11:00'}
{'user': 'acct:corenel@hypothes.is', 'text': '由于系统中的一些个体成员具有高容量，因此系统作为一个整体显然也具有高容量', 'origin_text': '。一种方法是使级联中靠后的成员单独具有高容量。在这种情况下，  !!!系统作为一个整体显然具有高容量，因为它的一些个体成员是高容量的!!!  。 还可以使用另一种级联，其中每个单独的模型具有低容量，但是由', 'time': '2017-01-20T11:14'}
{'user': 'acct:corenel@hypothes.is', 'text': '实现了', 'origin_text': '合，整个系统具有高容量。{Viola01}使用级联的增强决策树  !!!实现!!!  适合在手持数字相机中使用的快速并且鲁棒的面部检测器。本质上，它', 'time': '2017-01-20T11:15'}
{'user': 'acct:corenel@hypothes.is', 'text': '。分类器检查许多的窗口，如果这些窗口内不包含面部则拒绝。', 'origin_text': '棒的面部检测器。本质上，它们的分类器使用滑动窗口方法来定位面部  !!!，许多窗口会被检查，如果它们不包含面部则被拒绝。!!!  级联的另一个版本使用早期模型来实现一种硬性的注意机制：级联的早', 'time': '2017-01-20T11:18'}
{'user': 'acct:corenel@hypothes.is', 'text': '硬注意机制', 'origin_text': '它们不包含面部则被拒绝。级联的另一个版本使用早期模型来实现一种  !!!硬性的注意机制!!!  ：级联的早期成员定位对象，并且级联的后续成员在给定对象位置的情况', 'time': '2017-01-20T11:30'}
{'user': 'acct:corenel@hypothes.is', 'text': '级联前部的成员', 'origin_text': '被拒绝。级联的另一个版本使用早期模型来实现一种硬性的注意机制：  !!!级联的早期成员!!!  定位对象，并且级联的后续成员在给定对象位置的情况下执行进一步处理', 'time': '2017-01-20T11:32'}
{'user': 'acct:corenel@hypothes.is', 'text': '：', 'origin_text': '理。例如，Google使用两步级联从街景视图图像中转换地址编号  !!!，!!!  首先使用一个机器学习模型查找地址编号，然后使用另一个机器学习模型', 'time': '2017-01-20T11:32'}
{'user': 'acct:corenel@hypothes.is', 'text': '\\emph{选通器}', 'origin_text': '种方法没有实现加速推断计算的目标。类似的，我们可以使用称为  !!!选通器!!!  的神经网络来选择在给定当前输入的情况下将使用几个专家网络中的哪一', 'time': '2017-01-20T11:37'}
{'user': 'acct:corenel@hypothes.is', 'text': '\\emph{专家混合体}', 'origin_text': '用几个专家网络中的哪一个来计算输出。这个想法的第一个版本被称为  !!!专家混合体!!!  {cite?}，其中选通器为每个专家输出一个概率或权重（通过非线', 'time': '2017-01-20T11:38'}
{'user': 'acct:corenel@hypothes.is', 'text': '删去', 'origin_text': '个样本的选通器选择单个专家，我们就会获得一个特殊的硬专家混合体,  !!! % 刚性~!!!  {cite?}，这可以加速推断和训练的时间。当选通器决策的数量', 'time': '2017-01-20T11:56'}
{'user': 'acct:corenel@hypothes.is', 'text': '删去', 'origin_text': '的硬专家混合体, % 刚性~{cite?}，这可以加速推断和训练  !!!的时间!!!  。当选通器决策的数量很小的时候，这个策略效果会很好，因为它不是', 'time': '2017-01-20T11:57'}
{'user': 'acct:corenel@hypothes.is', 'text': '一种隐藏单元的条件Dropout的形式', 'origin_text': 't-al-arXiv2015}使用强化学习技术（策略梯度）来学习  !!!一种形式的隐藏单元的条件Dropout!!!  ，减少了实际的计算成本，而不会对近似的质量产生负面影响。另', 'time': '2017-01-21T03:48'}
{'user': 'acct:corenel@hypothes.is', 'text': '因而不能完全得到动态结构所带来的计算益处', 'origin_text': '是有效的。较为先进的方法一般采用对许多可能的输入使用加权平均，  !!!因此不能收获动态结构所有可能的计算益处!!!  。先进的注意机制在\\sec?中描述。使用动态结构化系统的', 'time': '2017-01-21T04:54'}
{'user': 'acct:corenel@hypothes.is', 'text': '将在', 'origin_text': '权平均，因此不能收获动态结构所有可能的计算益处。先进的注意机制  !!!在!!!  \\sec?中描述。使用动态结构化系统的主要障碍是由于系统针', 'time': '2017-01-21T04:54'}
{'user': 'acct:corenel@hypothes.is', 'text': 'CPU实现会十分缓慢', 'origin_text': '是，这些专用的子程序难以高效地实现。由于缺乏高速缓存的一致性，  !!!CPU实现将是缓慢的!!!  。GPU的实现也将是缓慢的，因为缺乏级联的内存操作以及warp', 'time': '2017-01-21T06:45'}
{'user': 'acct:corenel@hypothes.is', 'text': '此外，由于缺乏级联的内存操作以及warp成员使用不同分支时需要串行化操作，GPU的实现也会很慢', 'origin_text': '高效地实现。由于缺乏高速缓存的一致性，CPU实现将是缓慢的。  !!!GPU的实现也将是缓慢的，因为缺乏级联的内存操作以及warp成员使用不同分支时需要串行化操作!!!  。在一些情况下，可以将样本分成组缓解这些问题，这些组都采用相同', 'time': '2017-01-21T06:45'}
{'user': 'acct:corenel@hypothes.is', 'text': '可以通过将样本分成组，并且都采用相同的分支并且同时处理这些样本组的方式来缓解这些问题', 'origin_text': '作以及warp成员使用不同分支时需要串行化操作。在一些情况下，  !!!可以将样本分成组缓解这些问题，这些组都采用相同的分支并且同时处理这些样本组!!!  。在离线环境中，这是最小化处理固定量样本所需时间的一项可接受的', 'time': '2017-01-21T06:49'}
{'user': 'acct:corenel@hypothes.is', 'text': '然而在实时系统中，样本必须连续处理，对工作负载进行分区可能会导致负载均衡问题', 'origin_text': '线环境中，这是最小化处理固定量样本所需时间的一项可接受的策略。  !!!在实时系统中，样本必须连续处理，对工作负载进行分区可能会导致负载均衡问题!!!  。例如，如果我们分配一台机器处理级联中的第一步，另一台机器处理', 'time': '2017-01-21T06:50'}
{'user': 'acct:corenel@hypothes.is', 'text': '基于以电压或电流表示连续值的物理实现', 'origin_text': '专用集成电路的数字（基于数字的二进制表示），模拟{cite?}（  !!!基于作为电压或电流连续值的物理实现!!!  ）和混合实现（组合数字和模拟组件）。近年来更灵活的可编程门阵列', 'time': '2017-01-21T07:07'}
{'user': 'acct:corenel@hypothes.is', 'text': '现场可编程门阵列', 'origin_text': '值的物理实现）和混合实现（组合数字和模拟组件）。近年来更灵活的  !!!可编程门阵列!!!  实现（其中电路的具体细节可以建立后写入芯片）也得到了长足发展。', 'time': '2017-01-21T07:32'}
{'user': 'acct:corenel@hypothes.is', 'text': '在制造完成后', 'origin_text': '组件）。近年来更灵活的可编程门阵列实现（其中电路的具体细节可以  !!!建立后!!!  写入芯片）也得到了长足发展。虽然CPU和GPU上的软件实现通', 'time': '2017-01-21T07:32'}
{'user': 'acct:corenel@hypothes.is', 'text': '这与20世纪90年代的情况（上一个神经网络时代）的不同之处在于，神经网络的硬件实现（从开始到芯片可用可能需要两年）跟不上快速进展和价格低廉的通用CPU的脚步', 'origin_text': '最近计算速度的改进来自于核心的并行化（无论CPU还是GPU）。  !!!这与20世纪90年代的情况（前面的神经网络时代）非常不同，其中神经网络的硬件实现（从开始到芯片的可用性可能需要两年）不能跟上快速进展和价格低廉的通用CPU的脚步!!!  。因此，在针对诸如手机等低功率设备开发新的硬件设计时，研究专用', 'time': '2017-01-21T12:04'}
{'user': 'acct:corenel@hypothes.is', 'text': '因此，在针对诸如手机等低功率设备开发新的硬件设计，并且想要用于深度学习的一般公众应用（例如，具有语音、计算机视觉或自然语言功能的设施）等时，研究专用硬件能够进一步推动其发展。', 'origin_text': '性可能需要两年）不能跟上快速进展和价格低廉的通用CPU的脚步。  !!!因此，在针对诸如手机等低功率设备开发新的硬件设计时，研究专用硬件是进一步推动其发展的方式，旨在用于深度学习的一般公众应用（例如，具有语音、计算机视觉或自然语言功能的设施）。!!!  最近对基于反向传播神经网络的低精度实现的工作{cite?}表', 'time': '2017-01-21T12:55'}
{'user': 'acct:corenel@hypothes.is', 'text': '对与数字的', 'origin_text': '的要求。显而易见的是，在训练期间需要比在推断时更高的精度，并且  !!!数字!!!  某些形式的动态定点表示可以用于减少每个数需要的存储空间。传统的', 'time': '2017-01-21T12:56'}
{'user': 'acct:corenel@hypothes.is', 'text': '能够', 'origin_text': '训练期间需要比在推断时更高的精度，并且数字某些形式的动态定点表示  !!!可以用于!!!  减少每个数需要的存储空间。传统的定点数限制为固定范围（其对应于', 'time': '2017-01-21T12:56'}
{'user': 'acct:corenel@hypothes.is', 'text': '被限制在了一个固定范围之内', 'origin_text': '式的动态定点表示可以用于减少每个数需要的存储空间。传统的定点数  !!!限制为固定范围!!!  （其对应于浮点表示中的给定指数）。动态定点表示在一组数字 （例', 'time': '2017-01-21T12:57'}
{'user': 'acct:corenel@hypothes.is', 'text': '而动态定点表示', 'origin_text': '传统的定点数限制为固定范围（其对应于浮点表示中的给定指数）。  !!!动态定点表示!!!  在一组数字 （例如一个层中的所有权重） 之间共享该范围。使用定', 'time': '2017-01-21T12:57'}
{'user': 'acct:corenel@hypothes.is', 'text': '。', 'origin_text': '用较少的比特能够减少执行乘法所需的硬件表面积、功率需求和计算时间  !!!，!!!  并且乘法是使用或训练反向传播的现代深度网络中要求最高的操作。', 'time': '2017-01-21T12:58'}
{'user': 'acct:corenel@hypothes.is', 'text': '而乘法已经', 'origin_text': '较少的比特能够减少执行乘法所需的硬件表面积、功率需求和计算时间，  !!!并且乘法!!!  是使用或训练反向传播的现代深度网络中要求最高的操作。计算', 'time': '2017-01-21T12:58'}
{'user': 'acct:corenel@hypothes.is', 'text': '一直以来，', 'origin_text': '练反向传播的现代深度网络中要求最高的操作。计算机视觉  !!!一直以来!!!  计算机视觉就是深度学习应用中几个最活跃的研究方向之一。因为视觉', 'time': '2017-01-21T13:30'}
{'user': 'acct:corenel@hypothes.is', 'text': '由于生成模型已经是深度学习研究的指导原则，因此还有大量图像合成工作使用了深度模型', 'origin_text': '多数计算机视觉中的深度学习往往用于对象识别或者某种形式的检测。  !!!因为生成模型已经是深度学习研究的指导原则，还有大量使用深度模型的图像合成工作!!!  。尽管图像合成通常不包括在计算机视觉内，但是能够进行图像合成的', 'time': '2017-01-22T01:46'}
{'user': 'acct:corenel@hypothes.is', 'text': '即修复图像中的缺陷或从图像中移除对象这样的计算机视觉任务', 'origin_text': '包括在计算机视觉内，但是能够进行图像合成的模型通常用于图像恢复，  !!!修复图像中的缺陷或从图像中移除对象这样的计算机视觉任务!!!  。预处理许多应用领域需要复杂精细的预处理，因为原始', 'time': '2017-01-22T01:47'}
{'user': 'acct:corenel@hypothes.is', 'text': '由于原始输入往往以深度学习架构难以表示的形式出现，许多应用领域需要复杂精细的预处理。', 'origin_text': '缺陷或从图像中移除对象这样的计算机视觉任务。预处理  !!!许多应用领域需要复杂精细的预处理，因为原始输入以许多深度学习架构难以表示的形式出现。!!!  计算机视觉通常只需要相对少的这种预处理。图像应该被标准化，从', 'time': '2017-01-22T01:52'}
{'user': 'acct:corenel@hypothes.is', 'text': '池化区域', 'origin_text': '不总是必要的。一些卷积模型接受可变大小的输入并动态地调整它们的  !!!池区域!!!  大小以保持输出大小恒定{cite?}。其他卷积模型具有可变大小', 'time': '2017-01-22T01:54'}
{'user': 'acct:corenel@hypothes.is', 'text': '一种只对训练集做预处理', 'origin_text': '进行去噪或标注的模型{cite?}。数据集增强可以被看作是  !!!预处理训练集!!!  的方式。数据集增强是减少大多数计算机视觉模型泛化误差的一种极好', 'time': '2017-01-22T01:59'}
{'user': 'acct:corenel@hypothes.is', 'text': '测试时', 'origin_text': '数据集增强是减少大多数计算机视觉模型泛化误差的一种极好方法。在  !!!测试时间!!!  可用的一个相关想法是生成模型相同输入的许多不同版本（例如，在稍微', 'time': '2017-01-22T02:14'}
{'user': 'acct:corenel@hypothes.is', 'text': '类似想法', 'origin_text': '多数计算机视觉模型泛化误差的一种极好方法。在测试时间可用的一个  !!!相关想法!!!  是生成模型相同输入的许多不同版本（例如，在稍微不同的位置处裁剪的', 'time': '2017-01-22T02:14'}
{'user': 'acct:corenel@hypothes.is', 'text': '将同一输入的许多不同版本传给模型', 'origin_text': '视觉模型泛化误差的一种极好方法。在测试时间可用的一个相关想法是  !!!生成模型相同输入的许多不同版本!!!  （例如，在稍微不同的位置处裁剪的相同图像），并且在模型的不同实例', 'time': '2017-01-22T02:16'}
{'user': 'acct:corenel@hypothes.is', 'text': '其目的', 'origin_text': '助于减少泛化误差。其他种类的预处理被应用于训练集和测试集，  !!!目的!!!  是将每个样本置于更规范的形式，以便减少模型需要考虑的变化量。减', 'time': '2017-01-22T02:24'}
{'user': 'acct:corenel@hypothes.is', 'text': '减少数据中的变化量既能够减少泛化误差，也能够减小拟合训练集所需模型的大小。', 'origin_text': '的是将每个样本置于更规范的形式，以便减少模型需要考虑的变化量。  !!!减少数据中的变化量可以减少泛化误差并减小拟合训练集所需模型的大小。!!!  更简单的任务可以通过更小的模型来解决，而更简单的解决方案泛化能', 'time': '2017-01-22T02:43'}
{'user': 'acct:corenel@hypothes.is', 'text': '为啥注释也出来了', 'origin_text': '预处理通常是不必要的，并且最好只是让模型学习哪些变异性应该保留。  !!!%应该变得不变。!!!  例如，用于分类ImageNet的AlexNet系统仅具有一个预', 'time': '2017-01-22T03:02'}
{'user': 'acct:corenel@hypothes.is', 'text': '在许多任务中，对比度是能够安全移除的最为明显的变化源之一。', 'origin_text': 'e?}。\\subsubsection{对比度归一化}  !!!可以为许多任务安全移除的最明显的变化源之一是图像中的对比度量。!!!  对比度仅指图像中亮像素和暗像素之间差异的大小。量化图像对比度', 'time': '2017-01-22T05:37'}
{'user': 'acct:corenel@hypothes.is', 'text': '简单地说，对比度指的是图像中亮像素和暗像素之间差异的大小。', 'origin_text': '可以为许多任务安全移除的最明显的变化源之一是图像中的对比度量。  !!!对比度仅指图像中亮像素和暗像素之间差异的大小。!!!  量化图像对比度有许多方式。在深度学习中，对比度通常指的是图像', 'time': '2017-01-22T03:29'}
{'user': 'acct:corenel@hypothes.is', 'text': '因为没有', 'origin_text': '于某个常数sss来防止图像具有变化的对比度。这种方法非常复杂，  !!!没有!!!  缩放因子可以改变零对比度图像（所有像素都具有相等强度的图像）的对', 'time': '2017-01-22T05:53'}
{'user': 'acct:corenel@hypothes.is', 'text': '引入一个', 'origin_text': '以真实标准差通常仅能放大传感器噪声或压缩伪像。这种现象启发我们  !!!引入!!!  小的正的正则化参数λλ\\lambda来平衡估计的标准差。或者，', 'time': '2017-01-22T07:48'}
{'user': 'acct:corenel@hypothes.is', 'text': '感兴趣的', 'origin_text': 'X} )^2} }}.\\end{align}从大图像中剪切  !!!有趣!!!  对象所组成的数据集不可能包含任何具有几乎恒定强度的图像。在这些', 'time': '2017-01-22T07:49'}
{'user': 'acct:corenel@hypothes.is', 'text': '小区域', 'origin_text': '得激进的正则化更有用。在处理从CIFAR-10数据中随机选择的  !!!补丁!!!  时，{Coates2011}使用ϵ=0,λ=10ϵ=0,λ=10', 'time': '2017-01-22T07:51'}
{'user': 'acct:corenel@hypothes.is', 'text': '从而', 'origin_text': '不是L2L2L^2范数来定义GCN，因为标准差包括除以像素数量，  !!!因此!!!  基于标准差的GCN允许使用与图像大小无关的固定的sss。然而，', 'time': '2017-01-22T11:16'}
{'user': 'acct:corenel@hypothes.is', 'text': '能够', 'origin_text': '来定义GCN，因为标准差包括除以像素数量，因此基于标准差的GCN  !!!允许!!!  使用与图像大小无关的固定的sss。然而，观察到L2L2L^2范', 'time': '2017-01-22T11:16'}
{'user': 'acct:corenel@hypothes.is', 'text': '包括除以像素数量这一步', 'origin_text': '偏向于根据标准差而不是L2L2L^2范数来定义GCN，因为标准差  !!!包括除以像素数量!!!  ，因此基于标准差的GCN允许使用与图像大小无关的固定的sss。', 'time': '2017-01-22T11:16'}
{'user': 'acct:corenel@hypothes.is', 'text': '对此有所说明', 'origin_text': '们的直觉。我们可以把GCN理解成到球壳的一种映射。\\fig?  !!!给了一个说明!!!  。这可能是一个有用的属性，因为神经网络往往更好地响应空间方向，', 'time': '2017-01-22T11:21'}
{'user': 'acct:corenel@hypothes.is', 'text': '主成分', 'origin_text': '不同于GCN。sphering并不会使数据位于球形壳上，而是将  !!!主要分量!!!  重新缩放以具有相等方差，使得PCA使用的多变量正态分布具有球形等', 'time': '2017-01-22T11:29'}
{'user': 'acct:corenel@hypothes.is', 'text': '\\emph{白化}', 'origin_text': '用的多变量正态分布具有球形等高线。 sphering通常被称为  !!!白化!!!  。全局对比度归一化常常不能突出我们想要突出的图像特征，例如', 'time': '2017-01-22T11:30'}
{'user': 'acct:corenel@hypothes.is', 'text': '\\emph{sphering}', 'origin_text': '。}\\end{figure}与直觉相反的是，存在被称为  !!!sphering!!!  的预处理操作，并且它不同于GCN。sphering并不会使数据', 'time': '2017-01-22T11:31'}
{'user': 'acct:corenel@hypothes.is', 'text': '\\emph{局部对比度归一化}', 'origin_text': '存在大的差异。然而，它不能确保暗区内的边缘突出。这催生了  !!!局部对比度归一化!!!   。局部对比度归一化确保对比度在每个小窗口上被归一化，而不是作', 'time': '2017-01-22T11:32'}
{'user': 'acct:corenel@hypothes.is', 'text': '使用的则是', 'origin_text': '窗口中所有像素的平均值和标准差~{cite?}。在其他情况下，  !!!这是使用!!!  以要修改的像素为中心的高斯权重的加权平均和加权标准差。在彩色图', 'time': '2017-01-22T13:18'}
{'user': 'acct:corenel@hypothes.is', 'text': '归一化', 'origin_text': '处理不同的颜色通道，而其他策略组合来自不同通道的信息以使每个像素  !!!标准化!!!  {cite?}。局部对比度归一化通常可以通过使用可分离卷积', 'time': '2017-01-22T13:18'}
{'user': 'acct:corenel@hypothes.is', 'text': '元素级', 'origin_text': 'sec?）来计算特征映射所需要的局部平均值和局部标准差，然后使用  !!!元素层面!!!  的减法和元素层面的除法实现不同的特征映射。局部对比度归一化', 'time': '2017-01-22T13:19'}
{'user': 'acct:corenel@hypothes.is', 'text': '删去', 'origin_text': '特征映射所需要的局部平均值和局部标准差，然后使用元素层面的减法和  !!!元素层面的!!!  除法实现不同的特征映射。局部对比度归一化是可微分的操作，并', 'time': '2017-01-22T13:19'}
{'user': 'acct:corenel@hypothes.is', 'text': '作为一种非线性函数应用于网络隐藏层', 'origin_text': '不同的特征映射。局部对比度归一化是可微分的操作，并且还可以  !!!应用于网络隐藏层的非线性作用!!!  ，以及应用于输入的预处理操作。与全局对比度归一化一样，我们', 'time': '2017-01-22T13:20'}
{'user': 'acct:corenel@hypothes.is', 'text': '\\emph{自动语音识别}', 'origin_text': ',y_{N})表示目标的输出序列（通常是一个词或者字符的序列）。  !!!自动语音识别!!!  任务指的是构造一个函数$f^_{\\text{ASR}}，使得它能', 'time': '2017-01-23T01:38'}
{'user': 'acct:corenel@hypothes.is', 'text': '子音素状态', 'origin_text': '作由如下过程生成：首先，一个HMM生成了一个音素的序列以及离散的  !!!音素子状态!!!  （比如每一个音素的开始，中间，结尾），然后GMM把每一个离散的状', 'time': '2017-01-23T09:33'}
{'user': 'acct:corenel@hypothes.is', 'text': '当时', 'origin_text': '到90年代初期，大量语音识别系统使用了神经网络{cite?}。  !!!在那段时间!!!  ，基于神经网络的ASR的表现和GMM-HMM系统的表现差不多。', 'time': '2017-01-23T09:37'}
{'user': 'acct:corenel@hypothes.is', 'text': '这个结果优于或者说是可以与基于HMM的结果相比   \n', 'origin_text': 'footnote{39}）上达到了262626\\%的音素错误率，  !!!这个结果优于或者是可比于基于HMM的结果!!!  。从那时起，TIMIT成为了音素识别的一个基准数据集，在语音识', 'time': '2017-01-23T09:45'}
{'user': 'acct:corenel@hypothes.is', 'text': '结果是', 'origin_text': '的系统中已经付出的巨大努力，工业界并没有迫切转向神经网络的需求。  !!!结果!!!  ，直到21世纪00年代末期，学术界和工业界的研究者们更多的是用神', 'time': '2017-01-23T09:46'}
{'user': 'acct:corenel@hypothes.is', 'text': '对于基本的电话识别工作流程的一个扩展工作是', 'origin_text': '可以参考{mohamed2012understanding}。  !!!关于基本电话通道识别的一个扩展工作包括了!!!  添加说话人自适应相关特征{cite?}的方法，可以进一步地降低错', 'time': '2017-01-23T11:35'}
{'user': 'acct:corenel@hypothes.is', 'text': '这可以', 'origin_text': '一个扩展工作包括了添加说话人自适应相关特征{cite?}的方法，  !!!可以!!!  进一步地降低错误率。紧接着的工作是将结构从音素识别（TIMIT', 'time': '2017-01-23T11:35'}
{'user': 'acct:corenel@hypothes.is', 'text': '则是', 'origin_text': '特征{cite?}的方法，可以进一步地降低错误率。紧接着的工作  !!!是!!!  将结构从音素识别（TIMIT所主要关注的）转向了大规模词汇语音识', 'time': '2017-01-23T11:44'}
{'user': 'acct:corenel@hypothes.is', 'text': '手机端', 'origin_text': '这些合作所带来的突破性进展，这些技术现在被广泛应用在产品中，比如  !!!移动手机端!!!  。随后，当他们使用了越来越大的带标签的数据集，加入了各种初', 'time': '2017-01-23T11:51'}
{'user': 'acct:corenel@hypothes.is', 'text': '。', 'origin_text': '音识别性能上的这些突破是史无前例的（大约303030\\%的提高）  !!!，!!!  在这之前的长达十年左右的时间基于GMM-HMM的系统的传统技术已', 'time': '2017-01-23T11:53'}
{'user': 'acct:corenel@hypothes.is', 'text': '在这之前的长达十年左右的时间内，尽管数据集的规模随时间增长，然而基于GMM-HMM的系统的传统技术已经停滞不前了', 'origin_text': '识别性能上的这些突破是史无前例的（大约303030\\%的提高），  !!!在这之前的长达十年左右的时间基于GMM-HMM的系统的传统技术已经停滞不前了，尽管数据集的规模是随时间增长的!!!  （见{Deng+Yu-2014}的图2.4）。这也导致了语音识', 'time': '2017-01-23T11:54'}
{'user': 'acct:corenel@hypothes.is', 'text': '删去空格', 'origin_text': '至今。其中的一个创新点是卷积网络的应用~{cite?}。  !!!卷积网络 !!!  在时间和频率维度复用了权重，改进了之前的仅对时间使用重复权值的时', 'time': '2017-01-23T11:55'}
{'user': 'acct:corenel@hypothes.is', 'text': '在时域与频域上', 'origin_text': '其中的一个创新点是卷积网络的应用~{cite?}。卷积网络 在  !!!时间和频率维度!!!  复用了权重，改进了之前的仅对时间使用重复权值的时延神经网络。这', 'time': '2017-01-23T11:55'}
{'user': 'acct:corenel@hypothes.is', 'text': '在时域上', 'origin_text': 'te?}。卷积网络 在时间和频率维度复用了权重，改进了之前的仅  !!!对时间!!!  使用重复权值的时延神经网络。这种新的二维的卷积模型并不是将输入', 'time': '2017-01-23T11:57'}
{'user': 'acct:corenel@hypothes.is', 'text': '能够使用', 'origin_text': '信息~{cite?}。自然语言处理自然语言处理让计算机  !!!使用!!!  人类语言，例如英语或法语。让简单的程序能够高效明确地解析，计算', 'time': '2017-01-23T12:12'}
{'user': 'acct:corenel@hypothes.is', 'text': '为了让简单的程序能够高效明确地解析，计算机程序读取与发出的语言通常是经过特殊化的', 'origin_text': '语言处理自然语言处理让计算机使用人类语言，例如英语或法语。  !!!让简单的程序能够高效明确地解析，计算机程序通常读取和发出特殊化的语言!!!  。而自然的语言通常是模糊的，并且会违背形式的描述。自然语言处', 'time': '2017-01-23T12:30'}
{'user': 'acct:corenel@hypothes.is', 'text': '可能不遵循', 'origin_text': '程序通常读取和发出特殊化的语言。而自然的语言通常是模糊的，并且  !!!会违背!!!  形式的描述。自然语言处理中的应用如机器翻译，学习者必须用一种人', 'time': '2017-01-23T12:32'}
{'user': 'acct:corenel@hypothes.is', 'text': '自然语言处理包含了诸如机器翻译等的应用', 'origin_text': '殊化的语言。而自然的语言通常是模糊的，并且会违背形式的描述。  !!!自然语言处理中的应用如机器翻译!!!  ，学习者必须用一种人类语言读取句子并用另一种人类语言发出等同的句', 'time': '2017-01-23T12:32'}
{'user': 'acct:corenel@hypothes.is', 'text': '学习者需要读取一种人类语言的句子，并另一种人类语言发出等同的句子', 'origin_text': '模糊的，并且会违背形式的描述。自然语言处理中的应用如机器翻译，  !!!学习者必须用一种人类语言读取句子并用另一种人类语言发出等同的句子!!!  。许多NLP应用程序基于语言模型，语言模型定义了关于自然语言中', 'time': '2017-01-23T12:51'}
{'user': 'acct:corenel@hypothes.is', 'text': '、', 'origin_text': '许多NLP应用程序基于语言模型，语言模型定义了关于自然语言中的字  !!!，!!!  字符或字节序列的概率分布。与本章讨论的其他应用一样，非常', 'time': '2017-01-23T12:51'}
{'user': 'acct:corenel@hypothes.is', 'text': '通常我们必须使用', 'origin_text': '程序，一些领域特定的策略也很重要。为了构建自然语言的有效模型，  !!!通常必须使用!!!  专门处理序列数据的技术。在很多情况下，我们将自然语言视为一系列', 'time': '2017-01-23T12:52'}
{'user': 'acct:corenel@hypothes.is', 'text': '\\emph{语言模型}', 'origin_text': '意义上都高效，研究者已经开发了几种策略。nnn-gram  !!!语言模型!!!  定义了自然语言中标记序列的概率分布。根据模型的设计，标记可以是', 'time': '2017-01-24T03:12'}
{'user': 'acct:corenel@hypothes.is', 'text': '因为最大似然估计可以通过简单地统计每个可能的$n$-gram在训练集中出现的次数来获得。', 'origin_text': '小nnn值的不同模型建模。训练nnn-gram模型是简单的，  !!!因为最大似然估计可以简单地统计每个可能的nnn-gram在训练集中出现的次数。 !!!                                  ', 'time': '2017-01-24T08:04'}
{'user': 'acct:corenel@hypothes.is', 'text': '删去。（并入上一句）', 'origin_text': ', \\dots, x_{t-1}) }\\end{align}  !!!简单地查找两个存储的概率就能计算。!!!  为了在PnPnP_n中精确地再现推断，我们训练Pn−1Pn−1P', 'time': '2017-01-24T08:10'}
{'user': 'acct:corenel@hypothes.is', 'text': '这使得下式可以简单地通过查找两个存储的概率来计算', 'origin_text': '训练nnn-gram模型和n−1n−1n-1 gram模型。   !!!这使得它很容易计算概率!!!  ：P(xt∣xt−n+1,…,xt−1)=Pn(xt−n+1,', 'time': '2017-01-24T08:11'}
{'user': 'acct:corenel@hypothes.is', 'text': '最后一个字符', 'origin_text': '现推断，我们训练Pn−1Pn−1P_{n-1}时必须省略每个序列  !!!最后的字符!!!  。举个例子，我们演示三元模型如何计算句子”{\\tt THE ', 'time': '2017-01-24T08:17'}
{'user': 'acct:corenel@hypothes.is', 'text': '将演示', 'origin_text': '1P_{n-1}时必须省略每个序列最后的字符。举个例子，我们  !!!演示!!!  三元模型如何计算句子”{\\tt THE DOG RAN AWAY', 'time': '2017-01-24T08:28'}
{'user': 'acct:corenel@hypothes.is', 'text': '边际概率', 'origin_text': '为句子的开头没有上下文。取而代之，在句子的开头我们必须使用词的  !!!边缘概率!!!  。因此我们计算P3(𝚃𝙷𝙴\xa0𝙳𝙾𝙶\xa0𝚁𝙰𝙽)', 'time': '2017-01-24T08:48'}
{'user': 'acct:corenel@hypothes.is', 'text': '使用了', 'origin_text': '类别的概念，然后属于同一类别的词共享词之间的统计强度。这个想法  !!!使用!!!  聚类算法，基于它们与其他词同时出现的频率，将该组词分成集群或类。', 'time': '2017-01-25T02:43'}
{'user': 'acct:corenel@hypothes.is', 'text': '此处应分段', 'origin_text': '些问题，语言模型必须能够在一个词和其他语义相似的词之间共享知识。  !!!为了提高!!!  nnn-gram模型的统计效率，\\textbf{基于类的语言模型', 'time': '2017-01-25T02:44'}
{'user': 'acct:corenel@hypothes.is', 'text': '神经语言模型能够识别两个相似的词，并且不丧失将每个词编码为彼此不同的能力。', 'origin_text': '序列建模~{cite?}。不同于基于类的nnn-gram模型，  !!!神经语言模型在识别两个相似的词的基础上，而不丧失将每个词编码为彼此不同的能力。!!!  神经语言模型共享一个词（及其上下文）和其他类似词（和上下文之间', 'time': '2017-01-25T05:21'}
{'user': 'acct:corenel@hypothes.is', 'text': '句子长度的指数级别数量', 'origin_text': '个训练语句传递到指数数量的语义相关语句。维数灾难需要模型泛化到  !!!相对句子长度是指数多!!!  的句子。该模型通过将每个训练句子与指数数量的类似句子相关联克服', 'time': '2017-01-25T08:38'}
{'user': 'acct:corenel@hypothes.is', 'text': '不仅仅', 'origin_text': '剧性变化。使用分布式表示来改进自然语言处理模型的基本思想  !!!不用!!!  局限于神经网络。它还可以用于图模型，其中分布式表示是多个潜变量', 'time': '2017-01-25T09:05'}
{'user': 'acct:corenel@hypothes.is', 'text': '使用', 'origin_text': '示来改进自然语言处理模型的基本思想不用局限于神经网络。它还可以  !!!用于!!!  图模型，其中分布式表示是多个潜变量的形式。高维输出在许多', 'time': '2017-01-25T09:05'}
{'user': 'acct:corenel@hypothes.is', 'text': '计算成本是非常高的', 'origin_text': '单位。对于大词汇表，由于词汇量很大，在词的选择上表示输出分布的  !!!计算可能是昂贵的!!!  。在许多应用中，𝕍V\\SetV包含数十万词。表示这种分布的', 'time': '2017-01-25T09:55'}
{'user': 'acct:corenel@hypothes.is', 'text': '这造成了表示该矩阵的高存储成本，以及与之相乘的高计算成本。', 'origin_text': '|| \\SetV |，描述该仿射变换线性分量的权重矩阵非常大。  !!!这增加了表示该矩阵的高存储成本，以及乘以它的高计算成本。!!!  因为softmax要在所有|𝕍||V|| \\SetV |输出', 'time': '2017-01-25T11:00'}
{'user': 'acct:corenel@hypothes.is', 'text': '都有', 'origin_text': '练期间（计算似然性及其梯度）和测试期间（计算所有或所选词的概率）  !!!同时!!!  出现。对于专门的损失函数，可以有效地计算梯度 {cite?}，', 'time': '2017-01-25T11:02'}
{'user': 'acct:corenel@hypothes.is', 'text': '删去', 'origin_text': '?}，但是应用于传统softmax输出层的标准交叉熵损失时会出现  !!!了!!!  许多困难。假设hh\\Vh是用于预测输出概率ŷ\xa0y^\\hat', 'time': '2017-01-25T11:02'}
{'user': 'acct:corenel@hypothes.is', 'text': '。在', 'origin_text': ' O(|𝕍|nh)O(|V|nh)O(|\\SetV| n_h)  !!!。!!!  nhnhn_h为数千和|𝕍||V|| \\SetV |数十万的', 'time': '2017-01-25T11:03'}
{'user': 'acct:corenel@hypothes.is', 'text': '删去', 'origin_text': 'nn-gram模型提供。稍作修改，这种方法也可以在神经语言模型  !!!模型!!!  的softmax层中使用额外的输出值，而不是单独的sigmoid', 'time': '2017-01-25T11:14'}
{'user': 'acct:corenel@hypothes.is', 'text': '引发', 'origin_text': '模型的潜在泛化优势仅限于最常用的词，这大概是最没用的。这个缺点  !!!激发!!!  了处理高维输出替代方法的探索，如下所述。\\subsubsec', 'time': '2017-01-25T11:15'}
{'user': 'acct:corenel@hypothes.is', 'text': '无需进行', 'origin_text': '到log|𝕍|log\u2061|V|\\log |\\SetV|一样低，而  !!!无需!!!  与|𝕍||V||\\SetV|成比例数量（并且也与隐藏单元数量n', 'time': '2017-01-25T11:21'}
{'user': 'acct:corenel@hypothes.is', 'text': '等等。', 'origin_text': '构是先建立词的类别，然后是词类别的类别，然后是词类别的类别的类别  !!!等等!!!  这些嵌套类别构成一棵树，其叶子为词。在平衡树中，树的深度为lo', 'time': '2017-01-25T11:22'}
{'user': 'acct:corenel@hypothes.is', 'text': '事倍功半', 'origin_text': '关联的位数量近似等于该词频率的对数。然而在实践中，节省计算通常  !!!不值得努力!!!  ，因为输出概率的计算仅是神经语言模型中总计算的一部分。例如，假', 'time': '2017-01-25T13:41'}
{'user': 'acct:corenel@hypothes.is', 'text': '分支因子为$\\sqrt{|\\SetV|}$的树', 'origin_text': '得多，大约为10310310^3或更大。我们可以定义深度为2和  !!!分支因子为|𝕋|‾‾‾√|T|\\sqrt{|\\SetT|}的树!!!  ，而不用仔细优化分支因子为222的树。这样的树对应于简单定义一', 'time': '2017-01-25T13:43'}
{'user': 'acct:corenel@hypothes.is', 'text': '计算所有$|\\SetV|$个词', 'origin_text': '概率）都带来了计算上的好处。当然即使使用分层softmax，  !!!计算所有|𝕋||T||\\SetT|个词!!!  的概率仍将是昂贵的。另一个重要的操作是在给定上下文中选择最可能', 'time': '2017-01-25T13:52'}
{'user': 'acct:corenel@hypothes.is', 'text': '加速神经语言模型训练的一种方式是，避免明确计算所有未出现在下一位置的词对梯度的贡献。', 'origin_text': '为词类选择得不好。\\subsubsection{重要采样}  !!!加速神经语言模型训练的一种方式是避免明确计算所有词（未出现在下一位置）对梯度的贡献。!!!  每个不正确的词在此模型下应该具有低概率。枚举所有这些词的计算成', 'time': '2017-01-26T01:19'}
{'user': 'acct:corenel@hypothes.is', 'text': '删去', 'origin_text': '有词（未出现在下一位置）对梯度的贡献。每个不正确的词在此模型下  !!!应该!!!  具有低概率。枚举所有这些词的计算成本可能会很高。相反，我们可', 'time': '2017-01-26T01:20'}
{'user': 'acct:corenel@hypothes.is', 'text': 'pre-softmax', 'origin_text': 'al \\theta},\\end{align}其中aa\\Va是  !!!presoftmax!!!  激活（或得分）向量，每个词对应一个元素。第一项是\\textbf', 'time': '2017-01-26T01:21'}
{'user': 'acct:corenel@hypothes.is', 'text': '项，', 'origin_text': '第一项是\\textbf{正相}(positive phase)  !!!项!!!  推动ayaya_y向上，而第二项是\\textbf{负相}(neg', 'time': '2017-01-26T01:22'}
{'user': 'acct:corenel@hypothes.is', 'text': '；', 'origin_text': '{正相}(positive phase)项推动ayaya_y向上  !!!，!!!  而第二项是\\textbf{负相}(negative phase)', 'time': '2017-01-26T01:22'}
{'user': 'acct:corenel@hypothes.is', 'text': '的成本可能是很高的', 'origin_text': 'i出现的次数。由于各种原因，训练产生这种稀疏向量的机器学习模型  !!!可能是昂贵的!!!  。在学习的早期，模型可能不会真的使输出真正稀疏。此外，将输出', 'time': '2017-01-26T01:36'}
{'user': 'acct:corenel@hypothes.is', 'text': '负词是被随机选取的，如使用启发式采样更可能被误解的词。', 'origin_text': '正词”（在目标中非零的那些词）和相等数量的”负词”的重构损失。  !!!随机选择负词，如使用启发式采样更可能被误解的词。!!!  该启发式过采样引入的偏差则可以使用重要性权重校正。在所', 'time': '2017-01-26T03:49'}
{'user': 'acct:corenel@hypothes.is', 'text': '当然，避免每次计算时使用所有参数的模型则是一个例外。', 'origin_text': '。相比之下，将神经网络的参数数目加倍通常也大致加倍计算时间。  !!!避免每次计算时使用所有参数的模型是例外。!!!  嵌入层每次只索引单个嵌入，所以我们可以增加词汇量，而不会增加每', 'time': '2017-01-26T03:58'}
{'user': 'acct:corenel@hypothes.is', 'text': '集成学习领域', 'origin_text': '任何集成，如果集成成员产生独立的错误，这种技术可以减少测试误差。  !!!集成的领域!!!  提供了许多方法来组合集成成员的预测，包括统一加权和在验证集上选择', 'time': '2017-01-26T05:06'}
{'user': 'acct:corenel@hypothes.is', 'text': '理想情况下', 'origin_text': '”apple red”的短语。提议机制提出建议翻译的许多变体，  !!!理想地!!!  应包括”red apple”。翻译系统的第二个组成部分（语言模', 'time': '2017-01-26T05:09'}
{'user': 'acct:corenel@hypothes.is', 'text': '图像的标题生成', 'origin_text': '的系统。这个想法已经成功应用于很多领域，不仅仅是机器翻译，还包括  !!!为图像生成标题!!!  。}\\end{figure}\\begin{figure}[htp', 'time': '2017-01-26T08:14'}
{'user': 'acct:corenel@hypothes.is', 'text': '学习具有相同含义的句子的表示是有用的', 'origin_text': '方式。 早期模型只能表示单个词或短语。从表示学习的观点来看，  !!!具有相同含义的句子具有类似表示是有用的!!!  ，无论它们是以源语言还是以目标语言书写。研究者首先使用卷积和R', 'time': '2017-01-26T08:24'}
{'user': 'acct:corenel@hypothes.is', 'text': '删去', 'origin_text': '统的基于短语表中频率计数的方法相比，可以产生较低的对齐错误率。  !!!甚至!!!  有更早的工作{cite?}研究跨语言词向量。 这种方法的存在很', 'time': '2017-01-26T08:47'}
{'user': 'acct:corenel@hypothes.is', 'text': '在对', 'origin_text': '集上训练的更高效的跨语言对齐~{cite?} 。历史观点  !!!在!!!  反向传播的第一次探索中，{Rumelhart86b-small}', 'time': '2017-01-26T08:58'}
{'user': 'acct:corenel@hypothes.is', 'text': '为标志', 'origin_text': '自然语言处理的历史是由流行表示（对模型输入不同方式的表示）的变化  !!!标志!!!  的  。在早期对符号和词建模的工作之后，神经网络在NLP上一些', 'time': '2017-01-26T09:33'}
{'user': 'acct:corenel@hypothes.is', 'text': '对词建模', 'origin_text': '序列。{BenDucVin01-small} 将焦点重新引到  !!!建模词!!!  并引入神经语言模型，能产生可解释的词嵌入。这些神经模型已经从在', 'time': '2017-01-26T09:33'}
{'user': 'acct:corenel@hypothes.is', 'text': '基础的', 'origin_text': '在本节中，我们介绍深度学习一些其他类型的应用，它们与上面讨论的  !!!标准!!!  对象识别、语音识别和自然语言处理任务不同。本书的第三部分将扩大', 'time': '2017-01-26T09:34'}
{'user': 'acct:corenel@hypothes.is', 'text': '。', 'origin_text': '目的仍然是为了销售产品）。两者都依赖于预测用户和项目之间的关联  !!!，!!!   如果展示了广告或向该用户推荐了该产品，推荐系统要么预测一些行为', 'time': '2017-01-26T09:48'}
{'user': 'acct:corenel@hypothes.is', 'text': '推荐系统通过预测一些行为的概率（用户购买产品或该行为的一些代替）或预期增益（其可取决于产品的价值）来向用户展示广告或是推荐产品。', 'origin_text': '仍然是为了销售产品）。两者都依赖于预测用户和项目之间的关联，   !!!如果展示了广告或向该用户推荐了该产品，推荐系统要么预测一些行为的概率（用户购买产品或该行为的一些代替）或预期增益（其可取决于产品的价值）。!!!  目前，互联网的资金主要来自于各种形式的在线广告。经济的主要部', 'time': '2017-01-26T09:50'}
{'user': 'acct:corenel@hypothes.is', 'text': '都使用了', 'origin_text': '的主要部分依靠网上购物。 包括Amazon和eBay在内的公司  !!!使用!!!  机器学习（包括深度学习）推荐他们的产品。有时，项目不是实际出售', 'time': '2017-01-26T09:51'}
{'user': 'acct:corenel@hypothes.is', 'text': '这种关联问题可以视作监督学习问题来处理', 'origin_text': '话、推荐专家建议、匹配视频游戏的玩家或匹配约会的人。通常，  !!!这种关联问题像监督学习问题一样处理!!!  ：给出一些关于项目和关于用户的信息，预测感兴趣的行为（用户点击广', 'time': '2017-01-26T09:53'}
{'user': 'acct:corenel@hypothes.is', 'text': '泛化', 'origin_text': '些预测输入的最小信息：用户ID和项目ID。在这种情况下，唯一的  !!!推广!!!  方式依赖于不同用户或不同项目的目标变量值之间的模式相似性。假设', 'time': '2017-01-26T10:45'}
{'user': 'acct:corenel@hypothes.is', 'text': '二维或三维', 'origin_text': '{u,i}之间的平方误差。当用户嵌入和项目嵌入首次缩小到低维度（  !!!两个或三个!!!  ）时，它们就可以方便地可视化，或者可以将用户或项目彼此进行比较（', 'time': '2017-01-26T11:39'}
{'user': 'acct:corenel@hypothes.is', 'text': '缺失条目', 'origin_text': 'd \\MB = \\MV’$。SVD的一个问题是它以任意方式处理  !!!丢失的条目!!!  ，如同它们对应于目标值0。相反，我们希望避免为缺失条目做出的预', 'time': '2017-01-26T11:42'}
{'user': 'acct:corenel@hypothes.is', 'text': 'Netflix奖的预测比赛中（目的是仅基于大量匿名用户的之前评级预测电影的评级）', 'origin_text': '使用基于梯度的优化最小化。SVD和式 \\eq?中的双线性预测在  !!!Netflix奖（目的是仅基于大量匿名用户的之前评级预测电影的评级）的竞争中!!!  表现得非常好{cite?}。许多机器学习专家参加了2006年和', 'time': '2017-01-26T11:47'}
{'user': 'acct:corenel@hypothes.is', 'text': 'Netflix比赛方法的获胜方法中', 'origin_text': '经网络之一是基于RBM的无向概率模型~{cite?}。RBM是  !!!赢得Netflix比赛方法!!!  的一个重要组成部分{cite?}。神经网络社群中也已经探索了对', 'time': '2017-01-26T11:49'}
{'user': 'acct:corenel@hypothes.is', 'text': '专用的深度学习架构', 'origin_text': '目特征集到嵌入的映射可以通过深度学习架构学习{cite?}。  !!!专用深度学习架构!!!  ，如卷积网络已经应用于从丰富内容中提取特征，如提取用于音乐推荐的', 'time': '2017-01-26T11:51'}
{'user': 'acct:corenel@hypothes.is', 'text': '然后只能获得该类别正确与否的反馈', 'origin_text': '一个类别ŷ\xa0y^\\hat y（通常是基于模型最高概率的类别），  !!!无论这是否是正确的类别都只能获得反馈!!!  。显然，每个样本传达的信息少于监督的情况（其中真实标签yyy是', 'time': '2017-01-26T11:55'}
{'user': 'acct:corenel@hypothes.is', 'text': '比有监督的情况（其中真实标签$y$是可直接访问的）少', 'origin_text': '无论这是否是正确的类别都只能获得反馈。显然，每个样本传达的信息  !!!少于监督的情况（其中真实标签yyy是可直接访问的）!!!  ，因此需要更多的样本。更糟糕的是，如果我们不够小心，即使收集越', 'time': '2017-01-26T11:56'}
{'user': 'acct:corenel@hypothes.is', 'text': '选择', 'origin_text': '果我们不够小心，即使收集越来越多的数据，我们得到的系统可能会继续  !!!挑选!!!  错误的决定，因为正确的决定最初只有很低的概率：直到学习者选择正确', 'time': '2017-01-26T11:57'}
{'user': 'acct:corenel@hypothes.is', 'text': '。', 'origin_text': '的系统可能会继续挑选错误的决定，因为正确的决定最初只有很低的概率  !!!：!!!  直到学习者选择正确的决定之前都无法学习正确的决定。这类似于强化', 'time': '2017-01-26T11:58'}
{'user': 'acct:corenel@hypothes.is', 'text': '在学习者选择正确的决定之前，该系统都无法学习正确的决定。', 'origin_text': '系统可能会继续挑选错误的决定，因为正确的决定最初只有很低的概率：  !!!直到学习者选择正确的决定之前都无法学习正确的决定。!!!  这类似于强化学习的情况，其中仅观察到所选动作的奖励。一般来说，', 'time': '2017-01-26T11:59'}
{'user': 'acct:corenel@hypothes.is', 'text': '动作', 'origin_text': '例如，我们至少知道用户身份，并且我们要选择一个项目。从上下文到  !!!操作!!!  的映射也称为策略。学习者和数据分布（现在取决于学习者的行动）之', 'time': '2017-01-26T12:20'}
{'user': 'acct:corenel@hypothes.is', 'text': '动作', 'origin_text': '时更容易。在一般的强化学习场景中，高奖励或低奖励可能是由最近的  !!!行动!!!  或很久以前的行动引起的。术语contextual bandit', 'time': '2017-01-26T12:21'}
{'user': 'acct:corenel@hypothes.is', 'text': '动作', 'origin_text': '般的强化学习场景中，高奖励或低奖励可能是由最近的行动或很久以前的  !!!行动!!!  引起的。术语contextual bandit 指的是在一些输', 'time': '2017-01-26T12:21'}
{'user': 'acct:corenel@hypothes.is', 'text': '由于使用了符号\\citep{Rumelhart86b-small}和词嵌入\\citep{Deerwester90,BenDucVin01-small}，深度学习方法在语言模型、机器翻译和自然语言处理方面非常成功。\n', 'origin_text': 'tual bandit 的技术。知识表示、推理和回答  !!!深度学习方法在语言模型、机器翻译和自然语言处理方面非常成功，因为使用符号{cite?}和词嵌入{cite?}。!!!   这些嵌入表示关于单个词或概念的语义知识。研究前沿是为短语或', 'time': '2017-01-26T12:31'}
{'user': 'acct:corenel@hypothes.is', 'text': '则没有', 'origin_text': '一组有序的对象对。集合中的对具有这种关系，而那些不在集合中的对  !!!没有!!!  。例如，我们可以在实体集1,2,31,2,3{ 1, 2, 3', 'time': '2017-01-26T12:31'}
{'user': 'acct:corenel@hypothes.is', 'text': '以最大化捕获他们联合分布为训练目标', 'origin_text': '体和关系的表示可以将知识库中的每个三元组作为训练样本来学习，并且  !!!最大化捕获他们联合分布的训练目标!!!  {cite?}。除了训练数据，我们还需定义训练的模型族。一', 'time': '2017-01-26T12:52'}
{'user': 'acct:corenel@hypothes.is', 'text': '相当于', 'origin_text': '-2011} 用向量表示实体而矩阵表示关系，其思想是关系在实体上  !!!像!!!  运算符。或者，关系可以被认为是任何其他实体{cite?}，允许', 'time': '2017-01-26T13:05'}
{'user': 'acct:corenel@hypothes.is', 'text': '包括了', 'origin_text': '提供了有代表性的样本。第二部分介绍了涉及深度学习的现代实践，  !!!包括!!!  所有非常成功的方法。一般而言，这些方法使用代价函数的梯度寻找模', 'time': '2017-01-26T13:11'}
{'user': 'acct:corenel@hypothes.is', 'text': '。并且相比目前为止所描述的情况，其中的挑战更困难并且远远没有解决。', 'origin_text': '部分，开始进入研究领域，旨在使用较少的训练数据或执行更多样的任务  !!!，其中的挑战更困难并且远远没有解决（相比目前为止所描述的情况）。!!!                            ', 'time': '2017-01-26T13:12'}
{'user': 'acct:corenel@hypothes.is', 'text': '本项调查提供了在本文写作之时的具有代表性的样本。', 'origin_text': '景。我们不可能一下子描述全面覆盖主题的所有略微相似的应用 。  !!!在本文写作之时，这项调查尽可能提供了有代表性的样本。!!!  第二部分介绍了涉及深度学习的现代实践，包括所有非常成功的方法', 'time': '2017-01-26T13:15'}
{'user': 'acct:corenel@hypothes.is', 'text': '我们不可能全面描述与此主题相关的所有应用 。', 'origin_text': '（除了这里描述的应用以外），并且肯定会在此之后应用于更多的场景。  !!!我们不可能一下子描述全面覆盖主题的所有略微相似的应用 。!!!  在本文写作之时，这项调查尽可能提供了有代表性的样本。第二部', 'time': '2017-01-26T13:17'}
{'user': 'acct:corenel@hypothes.is', 'text': '记忆网络最开始是被用来完成一个玩具问答任务', 'origin_text': '特定声明性事实的最佳方法是使用显式记忆机制，如\\sec?所述。  !!!记忆网络首先被提出解决一个玩具问答任务!!!  {cite?}。{Kumar-et-al-arxiv2015}', 'time': '2017-01-26T13:18'}

=============================   Replies   =============================

{'user': 'acct:swordyork@hypothes.is', 'text': '已完成合并，你的建议都太好了！多谢！', 'time': '2017-03-03T10:52'}
